22

Folgende Antworten wurden erwartet und dienen als Grundlage für die Beurteilung:

 1. x sei eine Referenz auf einen Knoten (Typ Node) in einer einfach verketteten Liste
    mit mindestens einem existierenden Nachfolger (in der Objektvariablen next).
    Welche der folgenden Anweisungs-Sequenzen entfernen den direkten Nachfolger von x
    aus einer Liste, ändern sonst aber nichts?

    Falsch:  x.next.next = x.next;
    Falsch:  Node d = x.next; d = d.next;
    Falsch:  Node n = x.next.next; n.next = x;
    Falsch:  x.next.next = x.next.next.next;
    Falsch:  x.next.next.next = x.next.next;

 2. Welche der folgenden Aussagen stimmen in Bezug auf die Unterscheidung zwischen
    Datenstrukturen und abstrakten Datentypen?

    Richtig: Datenstrukturen sind unabhängig von bestimmten Programmiersprachen.
    Falsch:  Abstrakte Datentypen implementieren Algorithmen.
    Richtig: Abstrakte Datentypen lassen verwendete Algorithmen meist offen.
    Falsch:  Datenstrukturen implementieren abstrakte Datentypen.
    Richtig: Datenstrukturen stehen in engem Zusammenhang mit Algorithmen.

 3. x, y und z seien Objektreferenzen ungleich null.
    Welche der folgenden Bedingungen müssen für jede Implementierung der Methoden
    boolean equals(Object obj)  und  int hashCode()  in Java gelten?

    Falsch:  null.equals(null)  gibt  true  zurück.
    Richtig: Aus  x.equals(y)  folgt  x.hashCode() == y.hashCode().
    Richtig: Aus  x.equals(y)  folgt  y.equals(x).
    Richtig: Aus  x.equals(y)  und  x.equals(z)  folgt  y.equals(z).
    Richtig: Aus  x.hashCode() != y.hashCode()  folgt  !x.equals(y).

 4. t sei eine Variable mit einem einfachen (unbalancierten) binären Suchbaum
    ganzer Zahlen, der durch diese Anweisungen aufgebaut wurde:
        STree t = new STree(); t.add(4); t.add(9); t.add(7);
    Welche der folgenden Aussagen treffen auf t zu?

    Falsch:  Der Knoten mit Wert 7 ist die Wurzel.
    Richtig: Der Knoten mit Wert 7 ist ein Blattknoten.
    Falsch:  Der Knoten mit Wert 7 hat zumindest ein Kind.
    Richtig: Der Baum hat eine Tiefe von 3.
    Falsch:  Der Knoten mit Wert 9 ist ein Blattknoten.

 5. T sei ein Referenztyp (Klasse oder Interface), und
    x sei eine Variable eines Referenztyps mit  x != null.
    Welche der folgenden Aussagen treffen für alle T und x zu?

    Falsch:  Gilt  x instanceof T,  dann ist T eine Klasse.
    Falsch:  Gilt  x instanceof T,  dann ist T der deklarierte Typ von x.
    Falsch:  x.getClass()  liefert (interne Repr. vom) deklarierten Typ von x.
    Richtig: x.getClass()  liefert (interne Repr. vom) dynamischen Typ von x.
    Richtig: Aus  x.getClass() == T.class  folgt  x instanceof T.


Die Multiple-Choice-Fragen wurden folgendermaßen beantwortet
(das sind nur Ihre Antworten, keine Aussage über Korrektheit):

 1. x sei eine Referenz auf einen Knoten (Typ Node) in einer einfach verketteten Liste
    mit mindestens einem existierenden Nachfolger (in der Objektvariablen next).
    Welche der folgenden Anweisungs-Sequenzen entfernen den direkten Nachfolger von x
    aus einer Liste, ändern sonst aber nichts?
    
    Falsch:   x.next.next = x.next;
    Falsch:   Node d = x.next; d = d.next;
    Falsch:   Node n = x.next.next; n.next = x;
    Falsch:   x.next.next = x.next.next.next;
    Falsch:   x.next.next.next = x.next.next;

 2. Welche der folgenden Aussagen stimmen in Bezug auf die Unterscheidung zwischen
    Datenstrukturen und abstrakten Datentypen?
    
    Richtig:  Datenstrukturen sind unabhängig von bestimmten Programmiersprachen.
    Falsch:   Abstrakte Datentypen implementieren Algorithmen.
    Falsch:   Abstrakte Datentypen lassen verwendete Algorithmen meist offen.
    Richtig:  Datenstrukturen implementieren abstrakte Datentypen.
    Richtig:  Datenstrukturen stehen in engem Zusammenhang mit Algorithmen.

 3. x, y und z seien Objektreferenzen ungleich null.
    Welche der folgenden Bedingungen müssen für jede Implementierung der Methoden
    boolean equals(Object obj)  und  int hashCode()  in Java gelten?
    
    Falsch:   null.equals(null)  gibt  true  zurück.
    Richtig:  Aus  x.equals(y)  folgt  x.hashCode() == y.hashCode().
    Richtig:  Aus  x.equals(y)  folgt  y.equals(x).
    Richtig:  Aus  x.equals(y)  und  x.equals(z)  folgt  y.equals(z).
    Richtig:  Aus  x.hashCode() != y.hashCode()  folgt  !x.equals(y).

 4. t sei eine Variable mit einem einfachen (unbalancierten) binären Suchbaum
    ganzer Zahlen, der durch diese Anweisungen aufgebaut wurde:
        STree t = new STree(); t.add(4); t.add(9); t.add(7);
    Welche der folgenden Aussagen treffen auf t zu?
    
    Falsch:   Der Knoten mit Wert 7 ist die Wurzel.
    Richtig:  Der Knoten mit Wert 7 ist ein Blattknoten.
    Falsch:   Der Knoten mit Wert 7 hat zumindest ein Kind.
    Falsch:   Der Baum hat eine Tiefe von 3.
    Falsch:   Der Knoten mit Wert 9 ist ein Blattknoten.

 5. T sei ein Referenztyp (Klasse oder Interface), und
    x sei eine Variable eines Referenztyps mit  x != null.
    Welche der folgenden Aussagen treffen für alle T und x zu?
    
    Falsch:   Gilt  x instanceof T,  dann ist T eine Klasse.
    Falsch:   Gilt  x instanceof T,  dann ist T der deklarierte Typ von x.
    Falsch:   x.getClass()  liefert (interne Repr. vom) deklarierten Typ von x.
    Richtig:  x.getClass()  liefert (interne Repr. vom) dynamischen Typ von x.
    Richtig:  Aus  x.getClass() == T.class  folgt  x instanceof T.


